/*
* This Java source file was generated by the Gradle 'init' task.
*/
package ece651.riskgame.client;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ConnectException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import ece651.riskgame.shared.Action;
import ece651.riskgame.shared.BasicUnit;
import ece651.riskgame.shared.GameInfo;
import ece651.riskgame.shared.Move;
import ece651.riskgame.shared.PlaceAction;
import ece651.riskgame.shared.Territory;
import ece651.riskgame.shared.Unit;
import javafx.scene.text.Text;

public class App {
  private TextPlayer player;  
  private GameIO serverIO; 
  public static void main(String[] args) throws IOException, ClassNotFoundException{
    String ip = args[0];
    int port = -1;
    try {
      port = Integer.parseInt(args[1]);
    } catch (NumberFormatException e) {
      System.err.println("Argument" + args[1] + " must be an integer.");
      System.exit(1);
    }
    // connect to server
    Socket serverSocket = null;
    try {
      serverSocket = new Socket(ip, port);
    } catch (UnknownHostException e) {
      System.err.println("Don't know about host: " + ip);
      System.exit(1);
    } catch (ConnectException e) {
      System.err.println("Can not connect to server. Please contact 984-377-9836.");
      System.exit(1);
    }
    System.out.println("Connection Estabilished");

    GameIO serverIO = new GameIO(serverSocket);
    String color = serverIO.recvColor();
    GameInfo initializedGame = serverIO.recvGame();
    App app = new App(new TextPlayer(color, initializedGame), serverIO);

    app.doPlacementPhase();
    app.doActionPhases();
    //game over
    if (app.isOver()) {
      app.doGameOverPhase();
    }
    //player lost
    else {
      app.doPostDeathPhase();
    }
       
    serverSocket.close();
    System.exit(0);
  }

  /**
   * constructor of app
   * @param player is the current player of the game on this client program
   * @param io is the interface between client and server to send and recv objects  
   */
  public App(TextPlayer player, GameIO io) {
    this.player = player;
    this.serverIO = io;
  }


  /**
   * doPlacementPhase is used to send the initial placements to the server
   * @throws IOException when the initial units to allocate is not recieved
   * @thrwos ClassNotFoundException when failed to cast when recieving objects  
   */

  public void doPlacementPhase() throws IOException, ClassNotFoundException{
    List<Unit> unitsToPlace = serverIO.recvUnitsToPlace();
    List<PlaceAction> placementsToSend = player.readPlacements(unitsToPlace);
    serverIO.sendPlacements(player.adaptPlacements(placementsToSend));
    player.updateGame(serverIO.recvGame());
  }


  /**
   * doActionPhases is used to read valid actions from client and send them to the server
   * @throws IOException when latest game is not recieved
   */
  public void doActionPhases() throws IOException, ClassNotFoundException {
    while (player.isGameOver() || player.isLost()) {
      List<Action> actionsToSend = player.readActions();
      serverIO.sendActions(actionsToSend);
      player.updateGame(serverIO.recvGame());;
    }
  }

  /**
   * doGameOverPhase is used to declare the result and close I/O streams
   * @throws IOException when I/O streams fail to close
   */
  public void doGameOverPhase() throws IOException {
    player.doGameOverPhase();
  }

  
  /**
   * doPostDeathPhase is to let user choose speculate or quit after dead
   * client will spectate the rest of them if type "S"
   * client will quit the game if type "Q"
   * @throws IOException when nothing is typed
   */
  public void doPostDeathPhase() throws IOException {
    String choice = player.getPostDeathChoice();
    if (choice.equals("S")) {
      player.doSpectationPhase();
      player.doGameOverPhase();
    }
    else if (choice.equals("Q")) {
      player.doGameOverPhase();
    }
    else {
    }
  }
  public boolean isOver() {
    return player.isGameOver();
  }

}
